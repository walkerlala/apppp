import { DType, INDArray, TypedArray } from '../types';
export declare const inspectSymbol: unique symbol;
export declare class NDArray implements INDArray {
    static abs: <T extends NDArray>(x: T | ArrayLike<any>) => T;
    static acos: <T extends NDArray>(x: T | ArrayLike<any>) => T;
    static acosh: <T extends NDArray>(x: T | ArrayLike<any>) => T;
    static add: <T extends NDArray>(x: T | ArrayLike<any>, y: T | ArrayLike<any>, alpha?: number) => T;
    static angle: <T extends NDArray>(x: T | ArrayLike<any>, y: T | ArrayLike<any>) => number;
    static array: <T extends NDArray>(...args: any[]) => T;
    static asin: <T extends NDArray>(x: T | ArrayLike<any>) => T;
    static asinh: <T extends NDArray>(x: T | ArrayLike<any>) => T;
    static atan: <T extends NDArray>(x: T | ArrayLike<any>) => T;
    static atanh: <T extends NDArray>(x: T | ArrayLike<any>) => T;
    static augment: <T extends NDArray>(x: T | ArrayLike<any>, y: T | ArrayLike<any>) => T;
    static binOp: <T extends NDArray>(x: T | ArrayLike<any>, y: T | ArrayLike<any>, f: (a: number, b: number, index: number) => number) => T;
    static cbrt: <T extends NDArray>(x: T | ArrayLike<any>) => T;
    static ceil: <T extends NDArray>(x: T | ArrayLike<any>) => T;
    static check: <T extends NDArray>(x: T | ArrayLike<any>, ...indices: number[]) => void;
    static combine: <T extends NDArray>(x: T | ArrayLike<any>, y: T | ArrayLike<any>) => T;
    static copy: <T extends NDArray>(x: T | ArrayLike<any>) => T;
    static cos: <T extends NDArray>(x: T | ArrayLike<any>) => T;
    static cosh: <T extends NDArray>(x: T | ArrayLike<any>) => T;
    static cross: <T extends NDArray>(x: T | ArrayLike<any>, y: T | ArrayLike<any>) => T;
    static det: <T extends NDArray>(x: T | ArrayLike<any>) => number;
    static diagonal: <T extends NDArray>(x: T | ArrayLike<any>) => T;
    static dot: <T extends NDArray>(x: T | ArrayLike<any>, y: T | ArrayLike<any>) => number;
    static eig: <T extends NDArray>(x: T | ArrayLike<any>) => [T, T];
    static equals: <T extends NDArray>(x: T | ArrayLike<any>, y: T | ArrayLike<any>) => boolean;
    static equidimensional: <T extends NDArray>(x: T | ArrayLike<any>, y: T | ArrayLike<any>) => void;
    static equilateral: <T extends NDArray>(x: T | ArrayLike<any>, y: T | ArrayLike<any>) => void;
    static exp: <T extends NDArray>(x: T | ArrayLike<any>) => T;
    static expm1: <T extends NDArray>(x: T | ArrayLike<any>) => T;
    static eye: <T extends NDArray>(n: number) => T;
    static fill: <T extends NDArray>(x: T | ArrayLike<any>, value: number | ((index: number) => number)) => T;
    static floor: <T extends NDArray>(x: T | ArrayLike<any>) => T;
    static forEach: <T extends NDArray>(x: T, f: (value: number, i: number, src: TypedArray) => void) => void;
    static fround: <T extends NDArray>(x: T | ArrayLike<any>) => T;
    static gauss: <T extends NDArray>(x: T | ArrayLike<any>) => T;
    static get: <T extends NDArray>(x: T | ArrayLike<any>, ...indices: number[]) => number;
    static inv: <T extends NDArray>(x: T | ArrayLike<any>) => T;
    static log: <T extends NDArray>(x: T | ArrayLike<any>) => T;
    static log10: <T extends NDArray>(x: T | ArrayLike<any>) => T;
    static log1p: <T extends NDArray>(x: T | ArrayLike<any>) => T;
    static log2: <T extends NDArray>(x: T | ArrayLike<any>) => T;
    static lu: <T extends NDArray>(x: T | ArrayLike<any>) => [T, T, Int32Array];
    static lu_factor: <T extends NDArray>(x: T | ArrayLike<any>) => [T, Int32Array];
    static magic: <T extends NDArray>(size: number) => T;
    static map: <T extends NDArray>(x: T | ArrayLike<any>, f: (value: number, i: number, src: TypedArray) => number) => T;
    static matrix: <T extends NDArray>(r: number, c: number) => T;
    static max: <T extends NDArray>(x: T | ArrayLike<any>) => number;
    static mean: <T extends NDArray>(x: T | ArrayLike<any>) => number;
    static min: <T extends NDArray>(x: T | ArrayLike<any>) => number;
    static multiply: <T extends NDArray>(x: T | ArrayLike<any>, y: T | ArrayLike<any>) => T;
    static norm: <T extends NDArray>(x: T | ArrayLike<any>) => number;
    static normalize: <T extends NDArray>(x: T | ArrayLike<any>) => T;
    static ones: <T extends NDArray>(...shape: number[]) => T;
    static pow: <T extends NDArray>(x: T | ArrayLike<any>, exponent: number) => T;
    static prod: <T extends NDArray>(x: T | ArrayLike<any>) => number;
    static product: <T extends NDArray>(x: T | ArrayLike<any>, y: T | ArrayLike<any>) => T;
    static project: <T extends NDArray>(x: T | ArrayLike<any>, y: T | ArrayLike<any>) => T;
    static push: <T extends NDArray>(x: T | ArrayLike<any>, value: number) => T;
    static random: <T extends NDArray>(...shape: number[]) => T;
    static range: <T extends NDArray>(...args: number[]) => T;
    static rank: <T extends NDArray>(x: T | ArrayLike<any>) => number;
    static reciprocal: <T extends NDArray>(x: T | ArrayLike<any>) => T;
    static reduce: (x: NDArray, f: (acc: number, value: number, i: number, src: TypedArray) => number, initialValue?: number) => number;
    static reshape: <T extends NDArray>(x: T | ArrayLike<any>, ...shape: number[]) => T;
    static round: <T extends NDArray>(x: T | ArrayLike<any>) => T;
    static row_add: <T extends NDArray>(x: T | ArrayLike<any>, dest: number, source: number, scalar?: number) => T;
    static scale: <T extends NDArray>(x: T | ArrayLike<any>, scalar: number) => T;
    static set: <T extends NDArray>(x: T, ...args: number[]) => void;
    static sign: <T extends NDArray>(x: T | ArrayLike<any>) => T;
    static sin: <T extends NDArray>(x: T | ArrayLike<any>) => T;
    static sinh: <T extends NDArray>(x: T | ArrayLike<any>) => T;
    static slice: <T extends NDArray>(x: T | ArrayLike<any>, start?: number, step?: number, end?: number) => T;
    static solve: <T extends NDArray>(x: T | ArrayLike<any>, y: T | ArrayLike<any>) => T;
    static sqrt: <T extends NDArray>(x: T | ArrayLike<any>) => T;
    static square: <T extends NDArray>(x: T | ArrayLike<any>) => void;
    static subtract: <T extends NDArray>(x: T | ArrayLike<any>, y: T | ArrayLike<any>) => T;
    static sum: <T extends NDArray>(x: T | ArrayLike<any>) => number;
    static swap: <T extends NDArray>(x: T | ArrayLike<any>, i: number, j: number) => T;
    static tan: <T extends NDArray>(x: T | ArrayLike<any>) => T;
    static tanh: <T extends NDArray>(x: T | ArrayLike<any>) => T;
    static toArray: <T extends NDArray>(x: T | ArrayLike<any>) => number[];
    static toString: <T extends NDArray>(x: T | ArrayLike<any>) => string;
    static trace: <T extends NDArray>(x: T | ArrayLike<any>) => number;
    static transpose: <T extends NDArray>(x: T | ArrayLike<any>) => T;
    static trunc: <T extends NDArray>(x: T | ArrayLike<any>) => T;
    static zeros: <T extends NDArray>(...shape: number[]) => T;
    [inspectSymbol]: () => string;
    abs: () => this;
    acos: () => this;
    acosh: () => this;
    add: <T extends NDArray>(y: T, alpha?: number) => this;
    angle: <T extends NDArray>(x: T) => number;
    asin: () => this;
    asinh: () => this;
    atan: () => this;
    atanh: () => this;
    augment: <T extends NDArray>(x: T) => this;
    binOp: <T extends NDArray>(y: T, f: (a: number, b: number, index: number) => number) => this;
    cbrt: () => this;
    ceil: () => this;
    check: (...indices: number[]) => void;
    combine: <T extends NDArray>(x: T) => this;
    copy: () => this;
    cos: () => this;
    cosh: () => this;
    cross: <T extends NDArray>(x: T) => this;
    data: TypedArray;
    det: () => number;
    diagonal: () => this;
    dot: <T extends NDArray>(y: T) => number;
    dtype: DType;
    eig: <T extends NDArray>() => [T, T];
    equals: <T extends NDArray>(y: T) => boolean;
    equidimensional: <T extends NDArray>(y: T) => void;
    equilateral: <T extends NDArray>(y: T) => void;
    exp: () => this;
    expm1: () => this;
    fill: (value: number | ((index: number) => number)) => this;
    floor: () => this;
    forEach: (f: (value: number, i: number, src: TypedArray) => void) => void;
    fround: () => this;
    gauss: () => this;
    get: (...indices: number[]) => number;
    inv: () => this;
    length: number;
    log: () => this;
    log10: () => this;
    log1p: () => this;
    log2: () => this;
    lu: <T extends NDArray>() => [T, T, Int32Array];
    lu_factor: () => [this, Int32Array];
    map: (f: (value: number, i: number, src: TypedArray) => number) => this;
    max: () => number;
    mean: () => number;
    min: () => number;
    multiply: <T extends NDArray>(x: T) => this;
    norm: () => number;
    normalize: () => this;
    pow: (exponent: number) => this;
    prod: () => number;
    product: <T extends NDArray>(y: T) => this;
    project: <T extends NDArray>(x: T) => this;
    push: (value: number) => this;
    rank: () => number;
    reciprocal: () => this;
    reduce: (f: (acc: number, value: number, i: number, src: TypedArray) => number, initialValue?: number) => number;
    reshape: (...shape: number[]) => this;
    round: () => this;
    row_add: (dest: number, source: number, scalar?: number) => this;
    scale: (scalar: number) => this;
    set: (...args: number[]) => void;
    shape: number[];
    sign: () => this;
    sin: () => this;
    sinh: () => this;
    slice: (start?: number, step?: number, end?: number) => this;
    solve: <T extends NDArray>(x: T) => this;
    sqrt: () => this;
    square: () => void;
    subtract: <T extends NDArray>(y: T) => this;
    sum: () => number;
    swap: (i: number, j: number) => this;
    tan: () => this;
    tanh: () => this;
    toArray: () => number[];
    toString: () => string;
    trace: () => number;
    transpose: () => this;
    trunc: () => this;
    constructor(data?: any, options?: any);
    x: number;
    y: number;
    z: number;
    w: number;
    readonly T: this;
}
import './abs';
import './acos';
import './acosh';
import './add';
import './angle';
import './array';
import './asin';
import './asinh';
import './atan';
import './atanh';
import './augment';
import './binOp';
import './cbrt';
import './ceil';
import './check';
import './combine';
import './copy';
import './cos';
import './cosh';
import './cross';
import './det';
import './diagonal';
import './dot';
import './eig';
import './equals';
import './equidimensional';
import './equilateral';
import './exp';
import './expm1';
import './eye';
import './fill';
import './floor';
import './forEach';
import './fround';
import './gauss';
import './get';
import './inv';
import './log';
import './log10';
import './log1p';
import './log2';
import './lu';
import './lu_factor';
import './magic';
import './map';
import './matrix';
import './max';
import './mean';
import './min';
import './multiply';
import './norm';
import './normalize';
import './ones';
import './pow';
import './prod';
import './product';
import './project';
import './push';
import './random';
import './range';
import './rank';
import './reciprocal';
import './reduce';
import './reshape';
import './round';
import './row_add';
import './scale';
import './set';
import './sign';
import './sin';
import './sinh';
import './slice';
import './solve';
import './sqrt';
import './square';
import './subtract';
import './sum';
import './swap';
import './tan';
import './tanh';
import './toArray';
import './toString';
import './trace';
import './transpose';
import './trunc';
import './zeros';
